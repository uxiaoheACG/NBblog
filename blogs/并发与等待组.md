## GO语言并发

---
GO语言在并发这方面非常的优秀。只需要一个`go`关键字就可以开启一个协程  
这里要注意，协程≠线程
---

### 概念讲解

并发与并行：并发并不是真正意义上的同时执行。并行才是真正意义上的同时执行

| 比较项       | 并发（Concurrency）      | 并行（Parallelism）     |
|-----------|----------------------|---------------------|
| **定义**    | 多个任务交替执行，宏观“同时”      | 多个任务**真正同时**执行      |
| **核心目的**  | 提高**响应性**            | 提高**吞吐量**           |
| **运行方式**  | 一个核上“切换”多个任务         | 多个核上**同步**执行任务      |
| **实现方式**  | 调度器快速切换任务上下文         | 多核同时运行不同任务          |
| **例子**    | 单核CPU上运行多个 goroutine | 多核CPU上多个线程同时工作      |
| **Go 表现** | goroutine 调度本身是并发    | 配合多核+GOMAXPROCS 可并行 |

---

协程与线程：

| 比较项       | 协程（Coroutine）       | 线程（Thread）   |
|-----------|---------------------|--------------|
| **属于哪层**  | 用户态，语言级调度           | 操作系统内核态调度    |
| **调度者**   | 程序语言或运行时（如 Go）      | 操作系统         |
| **切换成本**  | 低（无系统调用，快速切换）       | 高（上下文切换慢）    |
| **资源消耗**  | 极小（KB 级栈空间）         | 高（MB 级栈空间）   |
| **可创建数量** | 多（成千上万）             | 少（几十到几百）     |
| **通信方式**  | 通常使用消息机制（如 channel） | 通常通过共享内存 + 锁 |
| **稳定性**   | 更容易内存泄漏（如泄露协程）      | 稳定性强，但更重     |
| **阻塞处理**  | 可由调度器挂起             | 一旦阻塞，占用线程资源  |


---

Go 自带一个强大的运行时调度器，核心结构是：

| 组件           | 作用                        |
|--------------|---------------------------|
| G（goroutine） | 协程任务                      |
| M（machine）   | OS 线程                     |
| P（processor） | 执行 goroutine 的资源上下文，任务队列等 |

	 
	
 
调度流程：  
- 程序执行 go func() 创建一个 G。

- 系统有若干个 P，P 中维护了 goroutine 队列。

- M（线程）不断从 P 中取出 goroutine 执行。

- 如果某个 goroutine 阻塞（如 IO、channel），M 会切换执行下一个 goroutine。

调度完全在用户态完成，无需操作系统介入，速度更快

### 案例讲解

协程使用实例：  
```
func main() {
	var wait sync.WaitGroup//定义等待组，用于确保每一个协程都完整运行

	num := 0

	for i := 0; i < 10; i++ {
		wait.Add(1)//给等待组添加一个等待
		go func() {
			defer wait.Done()//函数结束的时候删除一个等待
			for j := 0; j < 100; j++ {
				num++
				fmt.Println(num)
			}
		}()
	}
	wait.Wait()//程序运行到这里会阻塞，等待wait里面的等待全部结束之后才会继续
	fmt.Println("end")
}

```

**关于上述案例的讲解：**  
我们使用go关键字开启一个协程之后，主程序是不会阻塞的。也就是说程序运行的过程是：  
**程序开始-》开启协程-》执行所有语句-》结束程序**   
但是这里就会有一个问题：可能开启的协程还没结束，主程序就结束了。导致程序没报错但是却运行错误  
就像下面这个例子一样：  
```
func main() {
    num := 0

	for i := 0; i < 10; i++ {
		go func() {
			for j := 0; j < 100; j++ {
				num++
				fmt.Println(num)
			}
		}()
	}
	
	fmt.Println("end")
}

```
我们会发现，程序过早的结束了。这就是主程序过早结束导致的协程失效问题

## 等待组-WaitGroup

---
等待组是由sync包提供的，这个包还提供了很多的功能，这些功能后续会介绍  
WaitGroup使用方法很简单  

| 步骤                                                   | 作用              |
|------------------------------------------------------|-----------------|
| var wait sync.WaitGroup或wait := sync.WaitGroup{}     | 初始化等待组          |
| wait.Add(num int)                                    | 添加num个等待        |
| wait.Done()                                          | 删除一个等待          |
| wait.Wait()                                          | 阻塞当前程序，等待所有等待结束 |
